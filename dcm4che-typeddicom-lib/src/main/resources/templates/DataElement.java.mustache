// Auto generated
package org.dcm4che.typeddicom.dataelements;

import org.dcm4che.typeddicom.AbstractAttributesWrapper;
import org.dcm4che.typeddicom.AttributesWrapper;
{{#sequence}}
import org.dcm4che.typeddicom.AbstractSequenceItemWrapper;
import org.dcm4che.typeddicom.SequenceWrapper;
import org.dcm4che3.data.Attributes;
import org.dcm4che3.data.Sequence;
{{/sequence}}
{{^sequence}}
import org.dcm4che.typeddicom.AbstractDataElementWrapper;
import org.dcm4che.typeddicom.valuerepresentations.{{valueRepresentationWrapper}};
import org.dcm4che3.data.Attributes;
import org.dcm4che3.data.VR;
{{/sequence}}
import org.dcm4che3.data.Tag;
{{#sequence}}

import java.util.Arrays;
{{/sequence}}

{{{classJavaDoc}}}
{{#retired}}
@Deprecated
{{/retired}}
public class {{keyword}} extends {{#sequence}}SequenceWrapper<{{keyword}}, {{keyword}}.Item>{{/sequence}}{{^sequence}}AbstractDataElementWrapper implements {{valueRepresentationWrapper}}{{/sequence}} {
    /**
     * The <a href="https://dicom.nema.org/medical/dicom/current/output/chtml/part06/chapter_6.html">DICOM Tag</a> 
     * associated with this class.
     */
    public static final int TAG = {{tagConstant}};
{{^sequence}}
    /**
     * The <a href="https://dicom.nema.org/medical/dicom/current/output/chtml/part05/sect_6.2.html">DICOM Value 
     * Representation (VR)</a> associated with this class.
     */
    public static final VR VALUE_REPRESENTATION = VR.{{valueRepresentation}};

    /**
     * Creates a new {{name}} object which wraps the provided <code>attributes</code>.
     *
     * @param attributes The {@link Attributes} object to be wrapped.
     */
    public {{keyword}}(Attributes attributes) {
        super(attributes);
    }

    /**
     * Creates a new {{name}} object which wraps a new and empty {@link Attributes} object.
     */
    public {{keyword}}() {
        super();
    }
    
    /**
     * Returns a new {{name}} which wraps a copy of the Attributes wrapped in this {{name}}. (see {@link Attributes#Attributes(Attributes)}
     *
     * @return a new {{name}} which wraps a copy of the Attributes wrapped in this {{name}}. 
     */
    public {{keyword}} copy() {
        return super.copy({{keyword}}.class);
    }

    @Override
    public VR getValueRepresentation() {
        return VALUE_REPRESENTATION;
    }
{{/sequence}}
{{#sequence}}

    /**
     * Creates a new {{name}} object which wraps the provided <code>sequence</code>.
     *
     * @param sequence The {@link Sequence} object to be linked.
     */
    public {{keyword}}(Sequence sequence) {
        super(sequence, {{keyword}}.Item.class);
    }
{{/sequence}}

    @Override
    public int getTag() {
        return TAG;
    }
{{#sequence}}

    public static class Item extends AbstractSequenceItemWrapper {{^subDataElementMetaInfos.isEmpty}}implements {{{implementsHolderInterfaces}}} {{/subDataElementMetaInfos.isEmpty}}{

        /**
         * Creates a new {{name}} Item object which wraps the provided <code>attributes</code>.
         *
         * @param attributes The {@link Attributes} object to be wrapped.
         */
        public Item(Attributes attributes) {
            super(attributes);
        }

        /**
         * Creates a new {{name}} Item object which wraps a new and empty {@link Attributes} object.
         */
        public Item() {
            super();
        }

        /**
         * Returns a new {{name}} Item which wraps a copy of the Attributes wrapped in this {{name}}. (see {@link Attributes#Attributes(Attributes)}
         *
         * @return a new {{name}} Item which wraps a copy of the Attributes wrapped in this {{name}}. 
         */
        public Item copy() {
            return super.copy(Item.class);
        }
    }
{{/sequence}}
    
    /**
     * A class implementing this interface can hold attributes which contain the DICOM tag "{{name}}" (see {@link {{keyword}}})
     */
    public interface Holder<SELF extends Holder<SELF>> extends AttributesWrapper {
        /**
         * @param attributes An attributes object containing the {{name}} (see {@link {{keyword}}})
         * @return A wrapper object implementing the {@link Holder} interface. 
         */
        static Holder<SimpleHolder> wrap(Attributes attributes) {
            return AttributesWrapper.wrap(attributes, SimpleHolder.class);
        }

        /**
         * @return the {{name}} (see {@link {{keyword}}})
         */
        default {{keyword}} get{{keyword}}() {
        {{#sequence}}
            Sequence sequence = getAttributes().getSequence(TAG);
            if (sequence == null) {
                return null;
            }
            return new {{keyword}}(sequence);
        {{/sequence}}
        {{^sequence}}
            return new {{keyword}}(getAttributes());
        {{/sequence}}
        }

        {{#sequence}}
        /**
         * Adds a new {{name}}. (see {@link {{keyword}}})
         *
         * @param initialCapacity the initial capacity for the new {{name}}
         */
        default {{keyword}} new{{keyword}}(int initialCapacity) {
            return new {{keyword}}(getAttributes().newSequence(TAG, initialCapacity));
        }

        /**
         * Adds a new {{name}} (see {@link {{keyword}}}) and populates it with {@code elements}.
         * Since this method returns the object on which it is called, it can be used to easily synthesize an
         * AttributesWrapper with a fluent API. 
         *
         * @param elements The elements which should be in the sequence.
         * @return The AttributesWrapper on which this method is called. If you want to get the Sequence use
         *         {@link #new{{keyword}}} or {@link #ensure{{keyword}}}.
         */
        default SELF append{{keyword}}(Item... elements) {
            {{keyword}} sequence = new {{keyword}}(getAttributes().newSequence(TAG, elements.length));
            sequence.addAll(Arrays.asList(elements));
            return (SELF) this;
        }

        /**
         * Adds a new {{name}} (see {@link {{keyword}}}) if it does not already exist.
         * (see {@link Attributes#ensureSequence(int, int)}
         *
         * @param initialCapacity The initial capacity (see {@link java.util.ArrayList#ArrayList(int)}) if a new 
         *                        {{name}} is created.
         * @return Either the already existing {{name}} (see {@link {{keyword}}}) or a new one with capacity 
         *         <code>initialCapacity</code>.
         */
        default {{keyword}} ensure{{keyword}}(int initialCapacity) {
            return new {{keyword}}(getAttributes().ensureSequence(TAG, initialCapacity));
        }

        /**
         * Adds a new {{name}} (see {@link {{keyword}}}) with initial capacity 1 (see {@link #ensure{{keyword}}(int)})
         * if it does not already exist.
         *
         * @return Either the already existing {{name}} (see {@link {{keyword}}}) or a new one with capacity 1.
         */
        default {{keyword}} ensure{{keyword}}() {
            return ensure{{keyword}}(1);
        }

        {{/sequence}}
        {{^sequence}}
        /**
         * @return a Setter for the {{name}} (see {@link {{keyword}}}) which returns this AttributesWrapper
         *         on its .setXXXX() methods. This allows fluent object creation in the form of <br>
         *         {@code XXXIOD xxxIOD = new XXXIOD().getYYYYSetter().setYYYY(xxxxValue).getZZZZSetter().setZZZZ(zzzzValue);}
         */
        default {{valueRepresentationWrapper}}.Setter<{{keyword}}, SELF> get{{keyword}}Setter() {
            return new {{valueRepresentationWrapper}}.Setter<>(this.get{{keyword}}(), (SELF) this);
        }

        {{/sequence}}
        /**
         * @return Whether it contains the {{name}} (see {@link {{keyword}}})
         */
        default boolean contains{{keyword}}() {
            return getAttributes().contains(TAG);
        }

        /**
         * Removes the {{name}} (see {@link {{keyword}}}
         */
        default void remove{{keyword}}() {
            getAttributes().remove(TAG);
        }
    }
    
    private static class SimpleHolder extends AbstractAttributesWrapper implements Holder<SimpleHolder> {
        private SimpleHolder(Attributes attributes) {
            super(attributes);
        }
    }
}
